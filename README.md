<center><big><big><big><big><big>2022年复旦大学编译荣誉课PJ</big></big></big></big></big></center>

<center><big><big><big>马成 20307130112</big></big></big></center>

## 编译项目过程简介

### 词法和语法翻译

1. 设计语言的关键字，变量声明的词法规则，最后使用YACC工具，将自己设计的词法正确的给出并生成块交给后续操作，经过了这个步骤之后一个代码会变成稍有秩序的块列表。
2. 设计语言的语法，这时候为了要保证语法不能有二义性，同时为了使用YACC工具来降低编程难度一般要求设计的语法是LALR(1)的语法，这样YACC才能正常快速的工作。由此我们就将词块列表转化成了一个拥有树结构的语法树，树结构十分有利于后面的一系列分析。

### 类型检查

1. 在语法树中我们还保留了显示的数据类型，在语法中检查数据类型是较为方便。我们需要仔细考虑每一个语法的左右两边应该满足的条件，然后递归的调用和考虑左右两边的数据类型进行比较。同时综合考虑当前的节点的语法含义向上层传递该节点的数据类型。
2. 在继承和多态方面，我们为了减少编程难度我们要求了父类和子类中不可以用相同名字的成员变量，同名的成语函数必须要求函数签名相同。注意子类会继承父类的成员变量和函数，但是由于上面的约定，我们在做typecheck的时候暂时不需要考虑函数重载的问题。
3. 在typecheck的时候会顺便检查是否用重复的变量定义以及在后面的语句是不是出现了没有声明的变量或者成员函数。
4. 经过这一个操作之后会告诉用户没有通过typecheck的部分，如果通过这个检验之后才能保证数据类型等都没有问题，可以省去后面操作的特殊情况的考虑。

### 生成IR树

1. 相对于语法树，IR树的抽象程度更高，不会再考虑具体变量名只是用一个temp来表示，同时if和while这样的语句会被进一步解析成为跳转语句。
2. 为了实现一个节点内部的翻译不过多依赖于其他节点，我们经常需要使用eseq和seq这种树结构作为返回值来操作，这样可以让翻译更加灵活。
3. 这个时候需要考虑到多态的问题，解决方案是考虑所有类不同的成员函数和成员变量总量，构建一个哈希表，key是成员变量或者是成员函数的名字，value是对应的偏移量。每一次构建一个类的时候都给出足量的空间，将这个类拥有的成员函数和成员变量加入到对应的偏移位置中，这时候要注意父类中的成员函数如果被子类的成员函数重写需要进行覆盖，在typecheck中保证了成员变量不会有重写的情况。
4. 每一次使用一个类中的成员变量或者是成员函数的时候只需要查找偏移量表找到偏移量读出后使用即可，typecheck保证了对应偏移量中一定是有值的，否则在typecheck中就不出类中没有改成员变量或函数。
5. 经过了这一个操作之后，语法树变成了IR树，抽象程度变高，消去了数据类型的概念，同时命令减少IR树可以更加简单的翻译成汇编语言。

### IR树线性化、成块以及特殊处理

1. 生成IR树的时候提到为了翻译的方便和灵活经常使用使用eseq和seq这种树结构作为返回值，但是实际的汇编代码是一个线性的结构。因此我们需要解构这些命令，将他们做等价转换。最后我们就会得到一个没有eseq和seq命令的IR树，这样的树是一个类似线性的结构，非常有利于后续的解析。
2. 成块的过程就是将IR树遍历后如果发现有跳转命令就进行一个分块，这样保证每一个块中所有的命令是顺序执行的，同时每一个块的第一个命令都是一个label标记，最后一个命令都是一个跳转指令。这样会更有益于后续的翻译分析。
3. 最后可能还要做一些特殊处理，比较典型的就是比如我们本来应该默认当函数中所有语句都执行完毕的时候应该会有一个return语句，但是很多时候这种问题不方便检查，并且在一些语言中也不会有强制的要求，但是在汇编等一些中必须要显示的返回语句，所以需要再最后加一个统一的返回语句。由于在IR树中已经没有了数据类型的概念，这里只要`return -1`即可

### titling

1. 考虑得到的IR树，根据已知的目标代码(llvm或者assem)选择命令组进行翻译
2. 重点在于如何设计块，这样块需要保证可以覆盖IR树的所有部分，同时不能不能过于复杂否则极有可能影响最后的执行效率。
3. 经过了这个操作之后将IR树变成了一个目标代码，但是整体上还是使用了Temp的结构来表示变量，还需要对这个Temp做一些操作

### 产生块分析，活跃度分析等

1. 在tile的过程中我们会给出每一个命令对应的des变量，src变量以及跳转变量(如果没有跳转到一个label就默认是跳转到下一条指令)
2. 经过块分析之后我们就得到了每一个块的相关信息，知道了一个块的前去后序等。
3. 经过活跃度分析我们知道了变量之间的冲突关系，也知道了在执行一个命令的时候哪一些变量是livein或者liveout等

### SSA

1. 如果你需要的目标是llvm的话你需要做SSA才能被llvm工具采纳
2. 根据上面的块分析寻找每一个节点的必经节点，在进一步找到必经分界节点
3. 根据活跃度分析得到那一些位置需要加入phi函数来灵活的根据位置选择变量值。
4. 最后进行一个rename来完成静态单赋值
5. 由此就得到了可以真实使用的llvm的代码

### 寄存器分配

1. 如果你需要的目标函数是assem的话那么实际上你只有有限的寄存器可以使用，你需要将无限的temp分配给有限的寄存器中进行操作
2. 根据变量的冲突关系来建立一个栈，这个栈是一个维护了将来染色的顺序，一个边数小于k的节点会优先加入栈，加入栈的节点所有的边后会断开(在这个步骤认为断开，实际可以通过技巧不更改真实的数据机构)。最后可能会加入一些边数大于等于k的节点，这些节点是有可能需要做splile的节点
3. 根据栈的顺序对节点k染色，无法染色的节点只能splile到栈中，用一个哈希表纪录对应节点会splle到的位置方便后续的操作。
4. 对所有的temp进行rename，不需要splile的节点直接更改，需要的节点如果是des就在赋值后马上存入栈，否则就从栈中读出后马上使用。我们为了方便留下了r8-r10的寄存器专门给splile的节点使用。
5. 由此就得到了真实可以使用的assem代码

## 运行项目需要的环境

1. LLVM & Clang：要求 Clang 和 LLVM 的版本至少为 10.0，在Ubuntu20.04 或更新版本：执行以下命令即可安装。

   ```shell
   $ sudo apt-get install llvm
   $ sudo apt-get install clang
   ```
    安装完成后可以通过以下命令进行测试：

    ```shell
    $ clang -v # 查看版本，若出现版本信息则说明安装成功
    $ lli --version # 查看版本，若出现版本信息则说明安装成功
    ```

    安装llvm14
   ```shell
   $ wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -
   $ sudo add-apt-repository "deb http://apt.llvm.org/focal/ llvm-toolchain-focal-14 main"
   $ sudo apt-get update
   $ sudo apt-get install llvm-14-dev
   ```

2. Lex & Yacc：执行以下命令安装

    ```shell
    $ sudo apt-get install flex bison
    ```

    完成安装后可以通过以下命令进行测试：

    ```shell
    $ lex --version # 查看版本，若出现版本信息则说明安装成功
    $ yacc --version # 查看版本，若出现版本信息则说明安装成功
    ```

3. 交叉编译器 & qemu 模拟器：交叉编译器用于将汇编语言转变为arm机器码。下载压缩包`gcc-arm-8.2-2018.11-x86_64-arm-linux-gnueabihf.tar.xz`，然后在 linux 环境里执行：

   ```shell
   $ cd ~
   $ tar xf gcc-arm-8.2-2018.11-x86_64-arm-linux-gnueabihf.tar.xz
   $ echo "export PATH=~/gcc-arm-8.2-2018.11-x86_64-arm-linux-gnueabihf/bin:\$PATH" >> ~/.bashrc # or ~/.zshrc
   ```

   重启终端，尝试：

   ```shell
   $ arm-linux-gnueabihf-g++ -v # 查看版本，若出现版本信息则说明安装成功
   ```
   qemu模拟器用于执行交叉编译出的arm机器码，同交叉编译器配套在后面的实验中使用。下载压缩包`qemu-6.2.0.tar.xz`，然后在 linux 环境里执行：
   
   ```shell
   $ sudo apt install ninja-build
   $ ninja --version
   
   $ cd ~
   $ tar xf qemu-6.2.0.tar.xz
   $ cd qemu-6.2.0
   $ mkdir build
   $ cd build
   $ ../configure --target-list=arm-linux-user
   $ make -j4
   $ sudo make install
   ```
   
   完成安装后可以通过以下命令进行测试：
   
   ```shell
   $ qemu-arm --version # 查看版本，若出现版本信息则说明安装成功
   ```

## 自带的神秘小资料
1. report是课程报告
2. FDMJ2023 Grammar是编译器适配的语言的规则

## 运行项目

1. 在linux环境下输入make a.out 可以得到转换程序

2. 运行编译器需要两个参数，一个是需要运行的代码文件名注意这个文件要以.fmj为结尾，一个是编译方式可以选择llvm或arm。

   ```shell
   # 将a.fmj的内容编译成llvm形式
   ./a.out a.fmj llvm
   # 将a.fmj的内容编译成arm形式
   ./a.out a.fmj arm
   ```

3. make runarm 可以测试所有测试代码，将语法树输出到.ast文件中，将IR树输出到.ir中，将进行线性化的IR树输出到.stm中，将流等分析信息输出到.liv中，将转换出来的assem代码到.s文件,并使用模拟器运行

4. make runarm 可以测试所有测试代码，将语法树输出到.ast文件中，将IR树输出到.ir中，将进行线性化的IR树输出到.stm中，将流等分析信息输出到.liv中，将转换出来的llvm代码到.ll文件,并使用模拟器运行

5. make run 先后运行runarm和runllvm

6. 在定义的时候没有初始化的参数全都定义为0，包括所有类型

7. 对于没有定义的数组和Class类型相当于指针是NULL,如果不进行初始化就使用的话就会在运行的时候产生段错误，我认为这是正常现象

8. 几乎所有的测试都可以直接跑过，除了下述的测试中需要有一些输入

9. `mctest04`重点用于测试libsys，一开始是对getarrrray的测试不要输入超过10个数字。随后会输出前10个质数。后面是一个默比乌斯反言的模板题，你需要先输入一个T表示测试的组数，最后依次输入a,b,c,d。程序会给出满足x∈[c,a],y∈[d,b]且gcd(x,y)=1的(x,y)组数

10. `example`需要给出一个输入来确定数组的规模

11. `fibonacci`需要给出一个数字n，输出1~n的斐波那契数列数值，如果n大于47则会输出-1

12. `ttest06`和`ttest05`的输入在测试中用处不大，随便输入一个数字即可

